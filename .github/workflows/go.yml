name: Docker 容器化部署（结合 docker-compose）

on:
  push:
    branches: [ "main" ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: 构建 Docker 镜像并准备部署文件
        run: |
          # 生成 Dockerfile（与之前保持一致）
          cat > Dockerfile << 'EOF'
          FROM golang:1.24-alpine AS builder
          
          WORKDIR /app
          
          # 先处理依赖（单独复制依赖文件以利用缓存）
          COPY go.mod ./
          
          # 配置 GOPROXY 加速依赖下载
          RUN go env -w GO111MODULE=on && \
              go env -w GOPROXY=https://goproxy.cn,direct 
          
          # 复制源代码
          COPY . .
          
          # 显示代码结构和关键文件（辅助排查文件缺失）
          RUN echo "项目文件结构：" && ls -la && \
              echo "检查 main.go 是否存在：" && if [ -f "main.go" ]; then echo "存在"; else echo "不存在"; exit 1; fi
          
          # 安装完整编译工具链
          RUN apk add --no-cache gcc musl-dev libc6-compat
          
          # 编译前显示 Go 环境信息
          RUN go version && go env
          
          # 优化编译命令（增加详细输出，调整链接参数）
          RUN echo "开始编译..." && \
              GOOS=linux GOARCH=amd64 \
              CGO_ENABLED=1 \
              go build  -o myapp main.go && \
              echo "编译成功，检查可执行文件：" && ls -l myapp
          
          FROM alpine:3.18
          RUN apk add --no-cache ca-certificates tzdata libc6-compat
          WORKDIR /app
          COPY --from=builder /app/myapp .
          EXPOSE 8054
          CMD ["./myapp"]
          EOF
          
          
          # 构建镜像   # 构建时输出详细日志
          docker build -t myapp:latest . --progress=plain

          
          # 保存镜像为 tar 文件
          docker save -o myapp-image.tar myapp:latest
          
          # 验证文件（确保镜像和 docker-compose.yml 存在）
          ls -l myapp-image.tar
          ls -l docker-compose.yml  # 检查项目根目录的 docker-compose.yml

          chmod 644 ./myapp-image.tar  # 确保文件可读取
    
          # 打包到临时目录（使用当前用户有权限的路径）

          tar -czf /tmp/vUDgSEtLsz.tar.gz ./myapp-image.tar

      - name: 停止服务器上的旧服务（通过 docker-compose）
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.TEST_SERVER_HOST }}
          username: ${{ secrets.TEST_SERVER_USER }}
          key: ${{ secrets.TEST_SERVER_SSH_KEY }}
          port: ${{ secrets.TEST_SERVER_PORT || 22 }}
          script: |
            docker stop myapp-container || true
            docker rm myapp-container || true
            docker rmi myapp:latest || true
            TARGET_DIR="/home/testapp"
            # 进入目标目录，停止并删除旧服务
            cd $TARGET_DIR || mkdir -p $TARGET_DIR && cd $TARGET_DIR
            docker-compose down || true  # 若没有旧服务，忽略错误

      - name: 传输镜像和 docker-compose.yml 到服务器
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.TEST_SERVER_HOST }}
          username: ${{ secrets.TEST_SERVER_USER }}
          key: ${{ secrets.TEST_SERVER_SSH_KEY }}
          port: ${{ secrets.TEST_SERVER_PORT || 22 }}
          source: "myapp-image.tar,docker-compose.yml"  # 同时传输两个文件
          target: "/home/testapp"
          rm: true

      - name: 在服务器上加载镜像并通过 docker-compose 启动
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.TEST_SERVER_HOST }}
          username: ${{ secrets.TEST_SERVER_USER }}
          key: ${{ secrets.TEST_SERVER_SSH_KEY }}
          port: ${{ secrets.TEST_SERVER_PORT || 22 }}
          script: |
            TARGET_DIR="/home/testapp"
            cd $TARGET_DIR
            
            # 加载镜像
            docker load -i myapp-image.tar
            
            # 通过 docker-compose 启动服务
            docker-compose up -d
            
            # 验证服务状态
            sleep 2
            if docker-compose ps | grep "Up"; then
              echo "服务启动成功"
              docker-compose logs myapp  # 查看应用日志
            else
              echo "服务启动失败，查看日志："
              docker-compose logs myapp
              exit 1
            fi